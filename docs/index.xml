<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on Ostwind Documentation</title><link>https://ostwind.qubitpi.org/docs/</link><description>Recent content in Docs on Ostwind Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Jun 2025 04:01:38 +0530</lastBuildDate><atom:link href="https://ostwind.qubitpi.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Configuration</title><link>https://ostwind.qubitpi.org/docs/configuration/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/configuration/</guid><description>Configuration The configuration for Ostwind is implemented using ResourceConfig class programmatically wires up dependencies with a BinderFactory.
The configuration does not expose all the settings that can be customized. Some requires overriding of the injected dependency in AbstractBinderFactory, which offers the default dependency injection and resource binding.
The required bindings are
a FileStore implementation class
a MetaStore implementation class with dependencies of
a QueryDataFetcher for read operation and a MutationDataFetcher for write operation import org.</description></item><item><title>File Stores</title><link>https://ostwind.qubitpi.org/docs/filestore/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/filestore/</guid><description>A file store is responsible for:
reading and writing files (.mp3, .pdf, etc.) to/from an object store. Files of the following types are supported by Ostwind
PDF MP4 .txt file providing &amp;ldquo;transactions&amp;rdquo; that make all file operations atomic in a single request.
declaring the native object store client it delegates persistence operations to.
If a file store implementation is unable to handle a file InputStream, Ostwind pushes these responsibilities to the object store.</description></item><item><title>Getting Started</title><link>https://ostwind.qubitpi.org/docs/intro/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/intro/</guid><description>The easiest way to get started with Ostwind is to use the Ostwind Book App Starter. The starter bundles all of the dependencies we will need to stand up a web service. This tutorial uses the starter, and all of the code is available here. We will deploy and play with this example locally
Docker Compose Ostwind Compose is a tool for setting up and running a full-fledged Ostwind instance Docker application.</description></item><item><title>Glossary</title><link>https://ostwind.qubitpi.org/docs/glossary/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/glossary/</guid><description>This is collection of terms related to Ostwind and its concepts.
Application Concerns Health Check A Health Check is a mechanism to programatically assert if the web service is healthy or not in a binary yes/no fashion.
Feature Flag A Feature Flag is a boolean configuration mechanism that can be used to turn certain capabilities on or off via a simple flag-like setting.
System Config System Config is a layered configuration infrastructure that makes it easy to handle configuration within the code, as well as easy to specify configuration in different environments.</description></item><item><title>GraphQL</title><link>https://ostwind.qubitpi.org/docs/graphql/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/graphql/</guid><description>Graph APIs are an evolution of web service APIs that serve and manipulate data for mobile &amp;amp; web applications. They have a number of characteristics that make them well suited to this task:
Most notably, they present a data model as an entity relationship graph and an accompanying schema.
A well-defined model allows for a consistent view of the data and a centralized way to manipulate an instance of the model or to cache it.</description></item><item><title>JSON API</title><link>https://ostwind.qubitpi.org/docs/json-api/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/json-api/</guid><description>JSON-API is a specification for building REST APIs for CRUID (create, read, update, and delete) operations.
Similar to GraphQL, it allows the client to control what is returned in the response payload. Unlike GraphQL, the JSON-API spells out hot to perform file operations instead of file metadata operations.
JSON-API has no standardized schema introspection. However, Ostwind adds this capability to file service by exporting an Open API Initiative document (formerly known as Swagger).</description></item><item><title>Key Performance Indicators - Ostwind Web Service</title><link>https://ostwind.qubitpi.org/docs/kpi/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/kpi/</guid><description>These are the key performance indicators for the Ostwind Web Service component, listed in categories by order of importance.
Server Error Responses (HTTP 5XX) Shows how much trouble the service is having.
com.codahale.metrics.servlet.AbstractInstrumentedFilter.responseCodes.serverError.m1_rate Swift Errors Shows how much trouble queries are having against swift.
swift.errors.exceptions.m1_rate swift.errors.http.m1_rate Requests Shows how many requests the service is serving.
com.codahale.metrics.servlet.AbstractInstrumentedFilter.requests.m1_rate com.codahale.metrics.servlet.AbstractInstrumentedFilter.requests.m15_rate System Metrics Shows the overall health of the system&amp;rsquo;s low-level resources and activities.</description></item><item><title>Logging Guidelines</title><link>https://ostwind.qubitpi.org/docs/logging-guidelines/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/logging-guidelines/</guid><description>Logs are an important tool for debugging problems, as well as for gaining insight into how something is running under otherwise normal conditions. Because logs are so useful, it&amp;rsquo;s tempting to always log everything that&amp;rsquo;s going on, but processing logs is much more work than it would seem and writing too many logs has a significant negative impact on performance.
The Ostwind logs are Jetty logs, so they can be found wherever your Jetty instance stores its logs.</description></item><item><title>Monitoring and Operations</title><link>https://ostwind.qubitpi.org/docs/monitoring-and-operations/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/monitoring-and-operations/</guid><description>Ostwind was built from the start to be easy to operate and debug. There are 3 primary ways in which Ostwind makes debugging and gathering information about how it&amp;rsquo;s running easy.
Logs Ostwind has strict guidelines around what information should be logged, when it should be logged, and what level it should be logged at. Here&amp;rsquo;s a brief summary of the log levels and what they contain:
Level Meaning Error System-caused problem preventing correct results for requests.</description></item><item><title>System Configuration</title><link>https://ostwind.qubitpi.org/docs/system-config/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/system-config/</guid><description>Ostwind has two main configuration avenues, the domain object configuration (File Store, Meta Store, and Data Fetchers) which happens via compiled Java code, and system configuration via properties. The domain configuration is covered elsewhere, and we&amp;rsquo;ll only cover the system configuration infrastructure here.
The system for property configuration that Ostwind uses lives in it&amp;rsquo;s own sub-module. This system is extensible and reusable so that other Ostwind modules, and even other projects, can leverage it for their own property config needs.</description></item></channel></rss>