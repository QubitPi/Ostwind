<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developments on Ostwind Documentation</title><link>https://ostwind.qubitpi.org/development/</link><description>Recent content in Developments on Ostwind Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Jun 2025 19:16:15 +0530</lastBuildDate><atom:link href="https://ostwind.qubitpi.org/development/index.xml" rel="self" type="application/rss+xml"/><item><title>Basic Dependency Injection using Jersey's HK2</title><link>https://ostwind.qubitpi.org/development/jersey-di-using-hk2/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/jersey-di-using-hk2/</guid><description>Jersey uses HK2 as its dependency injection (DI) system. We can use other injection systems, but its infrastructure is built with HK2, and allows us to also use it within our applications.
Setting up simple dependency injection with Jersey takes just a few lines of code. Let say for example we have a service we would like to inject into our resources.
public class GreetingService { public String getGreeting(String name) { return &amp;#34;Hello &amp;#34; + name + &amp;#34;!</description></item><item><title>Development</title><link>https://ostwind.qubitpi.org/development/development/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/development/</guid><description>Ostwind is developed in Jersey framework.
NOTE: In case you are not familiar with Jersey, it is a parallel technology with &amp;ldquo;Spring Boot framework&amp;rdquo;. Ostwind offers absolutely NO support for Spring and will remain as an exclusive Jersey application in the future, because Jersey, alone with its backing technology HK2, is the reference-implementation of JSR-370 (and HK2, JSR-330) standards while Spring is not.
By &amp;ldquo;having no support for Spring&amp;rdquo;, Ostwind means the following:</description></item><item><title>Meta Stores - A abstraction layer for your file metadata API</title><link>https://ostwind.qubitpi.org/development/metastore/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/metastore/</guid><description>Ostwind meta store offers a GraphQL query language for file metadata API. GraphQL is a query language for APIs and a runtime for fulfilling those queries with our existing file metadata. Ostwind provides a complete and understandable description of the file data in its API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</description></item><item><title>Spinning Up A Local Swift Instance</title><link>https://ostwind.qubitpi.org/development/local-swift/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/local-swift/</guid><description>In this quickstart, we will download a OpenStack Swift Image, spinup a container on a single machine, upload a test file, and download that file.
Prerequisites You will need:
Docker command line tool Python 3 Getting started To download the image, issue the following commands in your terminal:
docker pull fnndsc/docker-swift-onlyone Setup Volume for Swift Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.</description></item><item><title>Testing</title><link>https://ostwind.qubitpi.org/development/test/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/test/</guid><description>Groovy Spock We&amp;rsquo;re big believers in testing our code, both for correctness, as well as to ensure that changes don&amp;rsquo;t unintentionally break existing contracts unintentionally. For example, we rely heavily on the Spock framework for our backend service tests, and see a lot of benefit from it&amp;rsquo;s conciseness, built-in mocking framework, and the fact that it uses Groovy.
We also strive for very high-quality code, with the belief that quality code is easier to maintain, easier to understand, and has fewer bugs.</description></item></channel></rss>