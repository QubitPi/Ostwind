<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ostwind Documentation</title><link>https://ostwind.qubitpi.org/</link><description>Recent content on Ostwind Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 25 Jul 2025 04:01:38 +0530</lastBuildDate><atom:link href="https://ostwind.qubitpi.org/index.xml" rel="self" type="application/rss+xml"/><item><title>Amazon S3 Concepts</title><link>https://ostwind.qubitpi.org/blog/amazon-s3/</link><pubDate>Fri, 25 Jul 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/blog/amazon-s3/</guid><description>Buckets A bucket is a container for objects stored in Amazon S3. Every object is contained in a bucket. For example, if the object named photos/puppy.jpg is stored in the awsexamplebucket1 bucket in the US West (Oregon) Region, then it is addressable using the URL https://awsexamplebucket1.s3.us-west-2.amazonaws.com/photos/puppy.jpg.
Buckets serve several purposes:
They organize the Amazon S3 namespace at the highest level. They identify the account responsible for storage and data transfer charges.</description></item><item><title>Basic Dependency Injection using Jersey's HK2</title><link>https://ostwind.qubitpi.org/development/jersey-di-using-hk2/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/jersey-di-using-hk2/</guid><description>Jersey uses HK2 as its dependency injection (DI) system. We can use other injection systems, but its infrastructure is built with HK2, and allows us to also use it within our applications.
Setting up simple dependency injection with Jersey takes just a few lines of code. Let say for example we have a service we would like to inject into our resources.
public class GreetingService { public String getGreeting(String name) { return &amp;#34;Hello &amp;#34; + name + &amp;#34;!</description></item><item><title>Development</title><link>https://ostwind.qubitpi.org/development/development/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/development/</guid><description>Ostwind is developed in Jersey framework.
NOTE: In case you are not familiar with Jersey, it is a parallel technology with &amp;ldquo;Spring Boot framework&amp;rdquo;. Ostwind offers absolutely NO support for Spring and will remain as an exclusive Jersey application in the future, because Jersey, alone with its backing technology HK2, is the reference-implementation of JSR-370 (and HK2, JSR-330) standards while Spring is not.
By &amp;ldquo;having no support for Spring&amp;rdquo;, Ostwind means the following:</description></item><item><title>Meta Stores - A abstraction layer for your file metadata API</title><link>https://ostwind.qubitpi.org/development/metastore/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/metastore/</guid><description>Ostwind meta store offers a GraphQL query language for file metadata API. GraphQL is a query language for APIs and a runtime for fulfilling those queries with our existing file metadata. Ostwind provides a complete and understandable description of the file data in its API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</description></item><item><title>Spinning Up A Local Swift Instance</title><link>https://ostwind.qubitpi.org/development/local-swift/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/local-swift/</guid><description>In this quickstart, we will download a OpenStack Swift Image, spinup a container on a single machine, upload a test file, and download that file.
Prerequisites You will need:
Docker command line tool Python 3 Getting started To download the image, issue the following commands in your terminal:
docker pull fnndsc/docker-swift-onlyone Setup Volume for Swift Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.</description></item><item><title>Testing</title><link>https://ostwind.qubitpi.org/development/test/</link><pubDate>Thu, 26 Jun 2025 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/development/test/</guid><description>Groovy Spock We&amp;rsquo;re big believers in testing our code, both for correctness, as well as to ensure that changes don&amp;rsquo;t unintentionally break existing contracts unintentionally. For example, we rely heavily on the Spock framework for our backend service tests, and see a lot of benefit from it&amp;rsquo;s conciseness, built-in mocking framework, and the fact that it uses Groovy.
We also strive for very high-quality code, with the belief that quality code is easier to maintain, easier to understand, and has fewer bugs.</description></item><item><title>Configuration</title><link>https://ostwind.qubitpi.org/docs/configuration/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/configuration/</guid><description>Configuration The configuration for Ostwind is implemented using ResourceConfig class programmatically wires up dependencies with a BinderFactory.
The configuration does not expose all the settings that can be customized. Some requires overriding of the injected dependency in AbstractBinderFactory, which offers the default dependency injection and resource binding.
The required bindings are
a FileStore implementation class
a MetaStore implementation class with dependencies of
a QueryDataFetcher for read operation and a MutationDataFetcher for write operation import org.</description></item><item><title>File Stores</title><link>https://ostwind.qubitpi.org/docs/filestore/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/filestore/</guid><description>A file store is responsible for:
reading and writing files (.mp3, .pdf, etc.) to/from an object store. Files of the following types are supported by Ostwind
PDF MP4 .txt file providing &amp;ldquo;transactions&amp;rdquo; that make all file operations atomic in a single request.
declaring the native object store client it delegates persistence operations to.
If a file store implementation is unable to handle a file InputStream, Ostwind pushes these responsibilities to the object store.</description></item><item><title>Getting Started</title><link>https://ostwind.qubitpi.org/docs/intro/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/intro/</guid><description>The easiest way to get started with Ostwind is to use the Ostwind Book App Starter. The starter bundles all of the dependencies we will need to stand up a web service. This tutorial uses the starter, and all of the code is available here. We will deploy and play with this example locally
Docker Compose Ostwind Compose is a tool for setting up and running a full-fledged Ostwind instance Docker application.</description></item><item><title>Glossary</title><link>https://ostwind.qubitpi.org/docs/glossary/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/glossary/</guid><description>This is collection of terms related to Ostwind and its concepts.
Application Concerns Health Check A Health Check is a mechanism to programatically assert if the web service is healthy or not in a binary yes/no fashion.
Feature Flag A Feature Flag is a boolean configuration mechanism that can be used to turn certain capabilities on or off via a simple flag-like setting.
System Config System Config is a layered configuration infrastructure that makes it easy to handle configuration within the code, as well as easy to specify configuration in different environments.</description></item><item><title>GraphQL</title><link>https://ostwind.qubitpi.org/docs/graphql/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/graphql/</guid><description>Graph APIs are an evolution of web service APIs that serve and manipulate data for mobile &amp;amp; web applications. They have a number of characteristics that make them well suited to this task:
Most notably, they present a data model as an entity relationship graph and an accompanying schema.
A well-defined model allows for a consistent view of the data and a centralized way to manipulate an instance of the model or to cache it.</description></item><item><title>JSON API</title><link>https://ostwind.qubitpi.org/docs/json-api/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/json-api/</guid><description>JSON-API is a specification for building REST APIs for CRUID (create, read, update, and delete) operations.
Similar to GraphQL, it allows the client to control what is returned in the response payload. Unlike GraphQL, the JSON-API spells out hot to perform file operations instead of file metadata operations.
JSON-API has no standardized schema introspection. However, Ostwind adds this capability to file service by exporting an Open API Initiative document (formerly known as Swagger).</description></item><item><title>Key Performance Indicators - Ostwind Web Service</title><link>https://ostwind.qubitpi.org/docs/kpi/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/kpi/</guid><description>These are the key performance indicators for the Ostwind Web Service component, listed in categories by order of importance.
Server Error Responses (HTTP 5XX) Shows how much trouble the service is having.
com.codahale.metrics.servlet.AbstractInstrumentedFilter.responseCodes.serverError.m1_rate Swift Errors Shows how much trouble queries are having against swift.
swift.errors.exceptions.m1_rate swift.errors.http.m1_rate Requests Shows how many requests the service is serving.
com.codahale.metrics.servlet.AbstractInstrumentedFilter.requests.m1_rate com.codahale.metrics.servlet.AbstractInstrumentedFilter.requests.m15_rate System Metrics Shows the overall health of the system&amp;rsquo;s low-level resources and activities.</description></item><item><title>Logging Guidelines</title><link>https://ostwind.qubitpi.org/docs/logging-guidelines/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/logging-guidelines/</guid><description>Logs are an important tool for debugging problems, as well as for gaining insight into how something is running under otherwise normal conditions. Because logs are so useful, it&amp;rsquo;s tempting to always log everything that&amp;rsquo;s going on, but processing logs is much more work than it would seem and writing too many logs has a significant negative impact on performance.
The Ostwind logs are Jetty logs, so they can be found wherever your Jetty instance stores its logs.</description></item><item><title>Monitoring and Operations</title><link>https://ostwind.qubitpi.org/docs/monitoring-and-operations/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/monitoring-and-operations/</guid><description>Ostwind was built from the start to be easy to operate and debug. There are 3 primary ways in which Ostwind makes debugging and gathering information about how it&amp;rsquo;s running easy.
Logs Ostwind has strict guidelines around what information should be logged, when it should be logged, and what level it should be logged at. Here&amp;rsquo;s a brief summary of the log levels and what they contain:
Level Meaning Error System-caused problem preventing correct results for requests.</description></item><item><title>System Configuration</title><link>https://ostwind.qubitpi.org/docs/system-config/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/docs/system-config/</guid><description>Ostwind has two main configuration avenues, the domain object configuration (File Store, Meta Store, and Data Fetchers) which happens via compiled Java code, and system configuration via properties. The domain configuration is covered elsewhere, and we&amp;rsquo;ll only cover the system configuration infrastructure here.
The system for property configuration that Ostwind uses lives in it&amp;rsquo;s own sub-module. This system is extensible and reusable so that other Ostwind modules, and even other projects, can leverage it for their own property config needs.</description></item><item><title>Yahoo Cloud Object Store - Object Storage at Exabyte Scale</title><link>https://ostwind.qubitpi.org/blog/yahoo-object-storage/</link><pubDate>Thu, 26 Jun 2025 04:01:38 +0530</pubDate><guid>https://ostwind.qubitpi.org/blog/yahoo-object-storage/</guid><description>Yahoo stores more than 250 Billion objects and half an exabyte of perpetually durable user content such as photos, videos, email, and blog posts. Object storage at Yahoo is growing at 20-25% annually. The growth is primarily driven by mobile, images, video, and user growth. Yahoo is betting on software defined storage to scale storage cost effectively along with the durability and latency guarantees.
Object Storage Landscape at Yahoo What is &amp;ldquo;object storage&amp;rdquo;?</description></item><item><title>Downloads</title><link>https://ostwind.qubitpi.org/general/downloads/</link><pubDate>Tue, 13 Sep 2022 19:16:15 +0530</pubDate><guid>https://ostwind.qubitpi.org/general/downloads/</guid><description>Downloads All recent supported releases may be downloaded from Maven Central: Download a release now!
News 26 June 2025: beta release available Complete change log for this release</description></item></channel></rss>